FIR robot ver 1.1 在這五子棋程式中,玩家可以: -自行選擇以黑子和白子(先手和後手)下棋 -隨機選擇的方式來決定以黑子或白子下棋 -隨機選擇的方式中可以重抽

在程式中:
 -沒有設計禁手以及時間限制
 -玩家可以悔棋(可多步回滾)
 -對局時會顯示該到哪一方下子(黑白方)
 -玩家可以重新開始這一局(不會改變黑白子及下棋順序)
 -完成對局後,玩家可以選擇再來一局(可以改變黑白子及下棋順序,包括自行選擇及隨機選擇) 
-對局時(玩家下棋時)及對局後可以退出程式

如何做: -使用了哪些庫: -<easy-x.h> -<windows.h> -<graphics.h> -<Windows.h> -<conio.h> -<time.h> -<stdlib.h> -<stdio.h>

-在Visual Studio 2019 上進行程式的編寫

UI部分:
	-以 easy-x 進行UI的繪製
	-以 random 的方式來實現隨機選擇的操作
	-以 grapjics.h 中的 MOUSEMSG 來實現程式中鼠標的操作

AI部分:(目前只有一層的思考)
	-在程序中寫入各種特殊棋型的模型

		寫入模型的 實現代碼(以活五棋型為例):
			int linkFive(point p1, point p2, point p3, point p4, point p5, int color) {//*****
				if (p1.state == p2.state &&
					p2.state == p3.state &&
					p3.state == p4.state &&
					p4.state == p5.state &&
					p5.state == color) return 1;
				return 0;
			}

	-在 robot2 函數中:
		-以 max 和 min 變量分別表示 AI方 與 敵方 可得到的最大分數,
			並以 max_p 以及 min_p 記錄所對應的位置
		-以 for 循環遍歷棋盤并將空格子以 checkVal 函數取得該格下不同子時的分數
		-遍歷時更新 max, min, max_p 以及 min_p 的值
		-遍歷完成後,比較 max 與 min 的大小,並返回 max_p 或 min_p 作為AI要下的位置

	-在 checkVal 函數中:
		-以 val 變量表示該格的分數
		-在 checkXX (XX為棋型代號) 函數中,利用該棋型的模型判斷這格可以形成該棋型的數量
		-將 checkXX 的值乘以該棋型的分數(儲存在 score 數組中),並加在 val 上
		-若果該格不能形成任何特殊棋型,則在 val 中加上象徵性的分數
		-返回 val 的值

			checkXX 的實現代碼(以活五棋型為例):
				int checkL5(point p1, struct point p[25][25], int color) {
					int count = 0;
					p[p1.place.x][p1.place.y].state = color;
					for (int i = Max(MIN, p1.place.x - WIN + 1); i < Min(MAX, p1.place.x + WIN); i++) {
						for (int j = Max(MIN, p1.place.y - WIN + 1); j < Min(MAX, p1.place.y + WIN); j++) {
							count += linkFive(p[i][j], p[i][j + 1], p[i][j + 2], p[i][j + 3], p[i][j + 4], color);
							count += linkFive(p[i][j], p[i + 1][j], p[i + 2][j], p[i + 3][j], p[i + 4][j], color);
							count += linkFive(p[i][j], p[i + 1][j + 1], p[i + 2][j + 2], p[i + 3][j + 3], p[i + 4][j + 4], color);
							count += linkFive(p[i][j], p[i + 1][j - 1], p[i + 2][j - 2], p[i + 3][j - 3], p[i + 4][j - 4], color);
						}
					}
					p[p1.place.x][p1.place.y].state = 0;
					return count;
				}
效果: 
-檔案大小: -cpp 檔(包括源文件及頭文件): 52kb -exe 檔: 161kb 
-運行狀況: -UI部分: 目前沒有出現會影響體驗的卡頓問題 -AI部分: 因只思考一層,AI目前能在1秒內下子 -棋力: 目前可以打敗棋力不太強的人

參考文獻: UI:https://blog.csdn.net/qq_63670969/article/details/125832296 分值參考:https://blog.csdn.net/Starry_error/article/details/125498493

更新:
 3/1/2023: 完成UI,AI(只有一層棋力) 
12/2/2023: 修改 UI ,現在鼠標靠近按鈕時按鈕內文字會變色
15/2/2023:整理代碼, MINIMAX算法已有雛形,但思考時間較長。 現在可以透過 setting.h 修改背景及按鈕顔色, 以及 AI 的思考模式(目前有minimax模式,貪心算法模式及完全隨機模式)